//================================================================================================
//
//【自作ライブラリ】計算処理[S_H_Calculation.h]
//Author:Hirasawa Shion
//
//================================================================================================
#ifndef _S_H_CALCULATION_H
#define _S_H_CALCULATION_H

#include "../3D/mesh.h"

//========================
//float型の範囲計算
// 概要	：一つ目の引数を範囲の絶対値に収めて返す
//------------------------
//	引数１	*pValue	：計算対象の変数のポインタ
//	引数２	fAbs	：範囲の絶対値
//========================
float Range(float *pValue, float fAbs);

//========================
//float型の範囲計算
// 概要	：1つ目の引数を、２・３個目の引数の範囲に収めて返す
//※オーバーロードしているRange関数はこの関数に集約する
//------------------------
//	引数１	*pValue	：計算対象の変数のポインタ
//	引数２	fMin	：範囲の最小値
//	引数３	fMax	：範囲の最大値
//========================
float Range(float *pValue, float fMin, float fMax);

//========================
//D3DXVECTOR3型の範囲計算
// 概要	：３つの引数の各ベクトルを範囲の絶対値に収めて返す
//========================
D3DXVECTOR3 Range(D3DXVECTOR3 *pValue, float fAbs);

//========================
//D3DXVECTOR3型の範囲計算
// 概要	：３つの引数の各ベクトルを範囲に収める
//========================
D3DXVECTOR3 Range(D3DXVECTOR3 *pValue, float fMin, float fMax);

//========================
//float型の範囲計算
// 概要	：一つ目の引数の各ベクトルを範囲の絶対値に収めて返す
//------------------------
//	引数１	*pValue	：計算対象の変数のポインタ
//	引数２	Abs		：範囲の絶対値
//========================
D3DXVECTOR3 Range(D3DXVECTOR3 *pValue, D3DXVECTOR3 Abs);

//========================
//D3DXVECTOR3型の範囲計算
// 概要	：３つの引数の各ベクトルを範囲に収める
//========================
D3DXVECTOR3 Range(D3DXVECTOR3 *pValue, D3DXVECTOR3 Min, D3DXVECTOR3 Max);

//========================
//逆の角度を求める
//------------------------
// 引数１	rot：修正する角度が入ったD3DXVECTOR3型のポインタ
// 返り値	引数の反対の角度を返す
//========================
float Inverse(float rot);

//========================
//角度修正
//------------------------
// 引数１	*pRot：修正する角度が入ったfloat型のポインタ
// 返り値	正しい角度を返す
//========================
float FixRotate(float *pRot);

//========================
//角度修正
// 概要	：各ベクトルの正しい角度をオーバーロードしているfloat型の「FixRotate関数」で取得する
//------------------------
// 引数１	*pRot：修正する角度が入ったD3DXVECTOR3型のポインタ
// 返り値	各ベクトルの正しい角度を返す
//========================
D3DXVECTOR3 FixRotate(D3DXVECTOR3 *pRot);

//========================
//ワールド座標を取得
//------------------------
// 引数１	Rot：オブジェクトの角度
// 引数２	size：オブジェクトのサイズ
// 引数３	Pos：オブジェクトの位置
// 返り値	計算したワールド座標を返す
//========================
D3DXVECTOR3 GetWorldPosition(float Rot, D3DXVECTOR3 size, D3DXVECTOR3 Pos);

//========================
//一番近い角度を返す
//------------------------
// 引数１	Rot			：基準の角度
// 引数２	fFrontLength：端から正面までの長さ
// 引数３	Pos			：判定を行う座標
// 引数４	RangeLeft	：判定を行う範囲の左側
// 引数５	RangeRight	：判定を行う範囲の右側
// 返り値	範囲の中で一番近い角度を返す
//				範囲内の場合：基準角度の逆を返す
//				範囲外の場合：範囲を超えているほうの角度を返す
//========================
float NearRotate(float Rot, float fFrontLength, D3DXVECTOR3 Pos, D3DXVECTOR3 RangeLeft, D3DXVECTOR3 RangeRight);

//========================
//交点を求める処理
// 概要	：２つの異なるベクトルが織りなす、三角形を使って交点を求める
//------------------------
// 引数１	pos		：基準の位置
// 引数２	VecMove	：基準〜対象位置までの移動ベクトル
// 引数３	StartPos：もう一つのベクトルの開始座標
// 引数４	EndPos	：もう一つのベクトルの終端座標
// 返り値	２つのベクトルの交点を返す
//========================
D3DXVECTOR3 CrossPoint(D3DXVECTOR3 pos, D3DXVECTOR3 VecMove, D3DXVECTOR3 StartPos, D3DXVECTOR3 EndPos);

//========================
//D3DXVECTOR3型の角度計算
// 概要	：この関数はXZ平面の想定で計算を行い、その角度を返す
//------------------------
// 引数１	v：座標を格納した変数
// 返り値	XZ平面の角度を返す
//========================
float atan2f(D3DXVECTOR3 v);

//========================
//D3DXVECTOR3型の各ベクトルの絶対値を返す
//------------------------
// 引数１	v：絶対値を取得したい変数
// 返り値	各ベクトルを「fabsf関数」を使用して得た絶対値を返す
//========================
D3DXVECTOR3 fabsV3(D3DXVECTOR3 v);

//========================
//一定の範囲内に対象物がいるかどうか捜索する
//------------------------
// 引数１	pos			：中心位置
// 引数２	TargetPos	：対象物の位置
// 引数３	fLeftAngle	：左端の角度
// 引数４	fRightAngle	：右端の角度
// 引数５	fLength		：範囲の長さ
// 返り値	捜索範囲内に対象がいるかどうか結果を返す	true：対象がいる	false：対象がいない
//========================
bool Search(D3DXVECTOR3 pos, D3DXVECTOR3 TargetPos, float fLeftAngle, float fRightAngle, float fLength);

//========================
//桁数を調べる
//------------------------
//引数　：桁数を調べたいint型の変数
//返り値：桁数
//========================
int Dejit(int nData);

//========================
//対象物の中にめり込んでいるかどうか判定
//------------------------
// 引数１	MinPos			：自分の最小位置
// 引数２	MaxPos			：自分の最大位置
// 引数３	TargetMinPos	：対象物の最小位置
// 引数４	TargetMaxPos	：対象物の最大位置
// 返り値	対象物にめりこんでいるかどうか	true：めりこんでいる	false：めりこんでいない
//========================
bool IsBoxCollision(D3DXVECTOR3 MinPos, D3DXVECTOR3 MaxPos, D3DXVECTOR3 TargetMinPos, D3DXVECTOR3 TargetMaxPos);

//=========================
//フィールド型のメッシュバッファーを取得
//=========================
CMesh::Buffer GetMeshBuffer(int nColumn, int nRow);

//=========================
//シリンダー型のメッシュバッファーを取得
//=========================
CMesh::Buffer GetMeshBuffer(int nDevide);

//=========================
//ランダムで角度を取得
//概要：全体の角度は3.14〜-3.14の6.28
//		その角度を算出するために、整数で628までの数値を乱数で取得し、
//		それを「-314」して乱数を「314〜-314」の間に直し、最終的に「÷100」して「3.14〜-3.14」にしたものを返す
//=========================
float RandomRotate(void);
#endif